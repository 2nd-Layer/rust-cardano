use std::{fmt};
use wallet_crypto::cbor::{ExtendedResult};
use wallet_crypto::{cbor};

use types::{HeaderHash, SlotId};
use genesis;
use normal;

#[derive(Debug, Clone)]
pub enum BlockHeader {
    GenesisBlockHeader(genesis::BlockHeader),
    MainBlockHeader(normal::BlockHeader),
}

impl BlockHeader {
    pub fn get_previous_header(&self) -> HeaderHash {
        match self {
            &BlockHeader::GenesisBlockHeader(ref blo) => blo.previous_header.clone(),
            &BlockHeader::MainBlockHeader(ref blo) => blo.previous_header.clone(),
        }
    }

    pub fn get_slotid(&self) -> SlotId {
        match self {
            &BlockHeader::GenesisBlockHeader(ref blo) => SlotId { epoch: blo.consensus.epoch, slotid: 0 },
            &BlockHeader::MainBlockHeader(ref blo) => blo.consensus.slot_id.clone(),
        }
    }

    pub fn compute_hash(&self) -> HeaderHash {
        let v = cbor::encode_to_cbor(self).unwrap();
        HeaderHash::new(&v[..])
    }
}

impl fmt::Display for BlockHeader {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            &BlockHeader::GenesisBlockHeader(ref mbh) => {
                write!(f, "{}", mbh)
            },
            &BlockHeader::MainBlockHeader(ref mbh) => {
                write!(f, "{}", mbh)
            },
        }
    }
}

#[derive(Debug)]
pub enum Block {
    GenesisBlock(genesis::Block),
    MainBlock(normal::Block),
}
impl Block {
    pub fn get_header(&self) -> BlockHeader {
        match self {
            &Block::GenesisBlock(ref blk) => BlockHeader::GenesisBlockHeader(blk.header.clone()),
            &Block::MainBlock(ref blk) => BlockHeader::MainBlockHeader(blk.header.clone()),
        }
    }
}

impl fmt::Display for Block {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            &Block::GenesisBlock(ref blk) => write!(f, "{}", blk),
            &Block::MainBlock(ref blk) => write!(f, "{}", blk)
        }
    }
}


// **************************************************************************
// CBOR implementations
// **************************************************************************

impl cbor::CborValue for Block {
    fn encode(&self) -> cbor::Value {
        unimplemented!()
    }
    fn decode(value: cbor::Value) -> cbor::Result<Self> {
        value.array().and_then(|array| {
            let (array, code)  = cbor::array_decode_elem(array, 0).embed("enumeration code")?;
            if code == 0u64 {
                let (array, blk) = cbor::array_decode_elem(array, 0)?;
                if ! array.is_empty() { return cbor::Result::array(array, cbor::Error::UnparsedValues); }
                Ok(Block::GenesisBlock(blk))
            } else if code == 1u64 {
                let (array, blk) = cbor::array_decode_elem(array, 0)?;
                if ! array.is_empty() { return cbor::Result::array(array, cbor::Error::UnparsedValues); }
                Ok(Block::MainBlock(blk))
            } else {
                cbor::Result::array(array, cbor::Error::InvalidSumtype(code))
            }
        }).embed("While decoding block::Block")
    }
}

impl cbor::CborValue for BlockHeader {
    fn encode(&self) -> cbor::Value {
        match self {
            &BlockHeader::GenesisBlockHeader(ref mbh) => {
                cbor::Value::Array(
                   vec![cbor::Value::U64(0), cbor::CborValue::encode(mbh)]
                )
            },
            &BlockHeader::MainBlockHeader(ref mbh) => {
                cbor::Value::Array(
                   vec![cbor::Value::U64(1), cbor::CborValue::encode(mbh)]
                )
            },
        }
    }
    fn decode(value: cbor::Value) -> cbor::Result<Self> {
        value.array().and_then(|array| {
            let (array, code)  = cbor::array_decode_elem(array, 0).embed("enumeration code")?;
            if code == 0u64 {
                let (array, mbh) = cbor::array_decode_elem(array, 0)?;
                if ! array.is_empty() { return cbor::Result::array(array, cbor::Error::UnparsedValues); }
                Ok(BlockHeader::GenesisBlockHeader(mbh))
            } else if code == 1u64 {
                let (array, mbh) = cbor::array_decode_elem(array, 0)?;
                if ! array.is_empty() { return cbor::Result::array(array, cbor::Error::UnparsedValues); }
                Ok(BlockHeader::MainBlockHeader(mbh))
            } else {
                cbor::Result::array(array, cbor::Error::InvalidSumtype(code))
            }
        })
    }
}

#[cfg(test)]
mod test {
    use wallet_crypto::{cbor};
    use wallet_crypto::util::hex;
    const MAINBLOCK_HEX : [u8;408] =
        [ 0x82, 0x01, 0x85, 0x00, 0x58, 0x20, 0xc4, 0xe0, 0xfc, 0x3a, 0x4f, 0xfb, 0x31, 0x91, 0xf8, 0x8b
        , 0x26, 0xa9, 0x83, 0x44, 0x53, 0xcb, 0xac, 0x0e, 0x6b, 0x9c, 0x8d, 0x8f, 0x7a, 0xe8, 0x10, 0x69
        , 0x6b, 0xee, 0x57, 0x5d, 0x1d, 0x22, 0x84, 0x83, 0x01, 0x58, 0x20, 0x96, 0xd3, 0x8c, 0x5a, 0xaf
        , 0xb8, 0x39, 0x45, 0x05, 0x11, 0xe1, 0xba, 0xe3, 0xb4, 0xec, 0xde, 0x21, 0x58, 0x88, 0xde, 0xe3
        , 0x40, 0x35, 0x26, 0xe2, 0x37, 0x3d, 0x01, 0x6f, 0xdf, 0xdd, 0x1e, 0x58, 0x20, 0x83, 0xac, 0x5d
        , 0x0d, 0x6a, 0xc0, 0xc0, 0x2a, 0xbf, 0x8c, 0x5a, 0xd7, 0x66, 0xd0, 0x13, 0x58, 0x73, 0xca, 0x4a
        , 0xc5, 0x3d, 0xd5, 0x82, 0x18, 0x7c, 0x9a, 0xa1, 0x5a, 0xa1, 0x49, 0xc0, 0xda, 0x82, 0x03, 0x58
        , 0x20, 0xc4, 0xe0, 0xfc, 0x3a, 0x4f, 0xfb, 0x31, 0x91, 0xf8, 0x8b, 0x26, 0xa9, 0x83, 0x44, 0x53
        , 0xcb, 0xac, 0x0e, 0x6b, 0x9c, 0x8d, 0x8f, 0x7a, 0xe8, 0x10, 0x69, 0x6b, 0xee, 0x57, 0x5d, 0x1d
        , 0x22, 0x58, 0x20, 0xc4, 0xe0, 0xfc, 0x3a, 0x4f, 0xfb, 0x31, 0x91, 0xf8, 0x8b, 0x26, 0xa9, 0x83
        , 0x44, 0x53, 0xcb, 0xac, 0x0e, 0x6b, 0x9c, 0x8d, 0x8f, 0x7a, 0xe8, 0x10, 0x69, 0x6b, 0xee, 0x57
        , 0x5d, 0x1d, 0x22, 0x58, 0x20, 0xc4, 0xe0, 0xfc, 0x3a, 0x4f, 0xfb, 0x31, 0x91, 0xf8, 0x8b, 0x26
        , 0xa9, 0x83, 0x44, 0x53, 0xcb, 0xac, 0x0e, 0x6b, 0x9c, 0x8d, 0x8f, 0x7a, 0xe8, 0x10, 0x69, 0x6b
        , 0xee, 0x57, 0x5d, 0x1d, 0x22, 0x84, 0x82, 0x01, 0x18, 0x2a, 0x58, 0x40, 0x1c, 0x0c, 0x3a, 0xe1
        , 0x82, 0x5e, 0x90, 0xb6, 0xdd, 0xda, 0x3f, 0x40, 0xa1, 0x22, 0xc0, 0x07, 0xe1, 0x00, 0x8e, 0x83
        , 0xb2, 0xe1, 0x02, 0xc1, 0x42, 0xba, 0xef, 0xb7, 0x21, 0xd7, 0x2c, 0x1a, 0x5d, 0x36, 0x61, 0xde
        , 0xb9, 0x06, 0x4f, 0x2d, 0x0e, 0x03, 0xfe, 0x85, 0xd6, 0x80, 0x70, 0xb2, 0xfe, 0x33, 0xb4, 0x91
        , 0x60, 0x59, 0x65, 0x8e, 0x28, 0xac, 0x7f, 0x7f, 0x91, 0xca, 0x4b, 0x12, 0x81, 0x18, 0x2a, 0x82
        , 0x00, 0x58, 0x40, 0xa9, 0x05, 0x22, 0x87, 0x4c, 0xcc, 0xf9, 0xa6, 0x7e, 0x20, 0x90, 0x31, 0xfd
        , 0x9d, 0xfe, 0x37, 0xa8, 0x2f, 0xd9, 0x43, 0xde, 0xe6, 0x33, 0x00, 0xaa, 0x82, 0x3c, 0xb9, 0x8e
        , 0x0f, 0x70, 0x4e, 0x91, 0x3f, 0x6e, 0x02, 0xb2, 0xaa, 0x0a, 0x33, 0x69, 0x3e, 0x05, 0x2c, 0x15
        , 0xf4, 0x3a, 0xee, 0x24, 0x21, 0x64, 0xd2, 0x81, 0x2a, 0x57, 0x2b, 0x27, 0x74, 0xc1, 0xb5, 0xad
        , 0xa8, 0x18, 0x01, 0x84, 0x83, 0x00, 0x01, 0x00, 0x82, 0x6a, 0x63, 0x61, 0x72, 0x64, 0x61, 0x6e
        , 0x6f, 0x2d, 0x73, 0x6c, 0x00, 0xa0, 0x58, 0x20, 0xc4, 0xe0, 0xfc, 0x3a, 0x4f, 0xfb, 0x31, 0x91
        , 0xf8, 0x8b, 0x26, 0xa9, 0x83, 0x44, 0x53, 0xcb, 0xac, 0x0e, 0x6b, 0x9c, 0x8d, 0x8f, 0x7a, 0xe8
        , 0x10, 0x69, 0x6b, 0xee, 0x57, 0x5d, 0x1d, 0x22];
    const GENESISBLOCK_HEX : [u8;78] =
        [ 0x82, 0x00, 0x85, 0x00, 0x58, 0x20, 0xc4, 0xe0, 0xfc, 0x3a, 0x4f, 0xfb, 0x31, 0x91, 0xf8, 0x8b
        , 0x26, 0xa9, 0x83, 0x44, 0x53, 0xcb, 0xac, 0x0e, 0x6b, 0x9c, 0x8d, 0x8f, 0x7a, 0xe8, 0x10, 0x69
        , 0x6b, 0xee, 0x57, 0x5d, 0x1d, 0x22, 0x58, 0x20, 0xc4, 0xe0, 0xfc, 0x3a, 0x4f, 0xfb, 0x31, 0x91
        , 0xf8, 0x8b, 0x26, 0xa9, 0x83, 0x44, 0x53, 0xcb, 0xac, 0x0e, 0x6b, 0x9c, 0x8d, 0x8f, 0x7a, 0xe8
        , 0x10, 0x69, 0x6b, 0xee, 0x57, 0x5d, 0x1d, 0x22, 0x82, 0x01, 0x81, 0x00, 0x81, 0xa0];

    const MAINBLOCK_HASH : &str = "12d339c93f216d1b775297dcf465428aa43f73518466bf72fc6413448ec27069";
    const GENESIS_HASH : &str = "0027f90a735237e2555b418ac4e02d35daf75945aad6253c7ac0bc7b121f974b";

    fn check_blockheader_serialization(header_raw: &[u8], hash: &str) {
        let header : super::BlockHeader = cbor::decode_from_cbor(header_raw).unwrap();
        let got_raw = cbor::encode_to_cbor(&header).unwrap();
        assert_eq!(header_raw, &got_raw[..]);
        let got_hash = header.compute_hash();
        let got_hex = hex::encode(got_hash.as_ref());
        assert_eq!(hash, got_hex)
    }

    #[test]
    fn check_genesis_block() {
        check_blockheader_serialization(&GENESISBLOCK_HEX[..], GENESIS_HASH);
    }

    #[test]
    fn check_main_block() {
        check_blockheader_serialization(&MAINBLOCK_HEX[..], MAINBLOCK_HASH);
    }
}